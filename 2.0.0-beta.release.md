# What's new ?

From the biggest, to the smallest:

* Connector is dead, long live Skupper routers !
* Microservices public ports
* New Volume deployment kind
* Detach/Attach an Agent from/to an ECN
* Move a microservice to another Agent
* Prune Docker on a remote Agent
* Configure default namespace
* Small changes to the microservice yaml structure

However, as to not overwhelm our users, the changes will be explained from the smallest to the biggest.

## Small changes to the microservice yaml structure

We realised that the specification for microservices were a bit confusing, so we have added a new `container` key in the spec. The container key contains all configuration related to the actual Docker container running on the Agent.

We also bumped the `apiVersion` to `iofog.org/v2`.

Before:
```yaml
apiVersion: iofog.org/v1
kind: Microservice # Or application, as application uses the same spec for its microservices
metadata:
  name: my-msvc
spec:
  agent:
    name: agent-name
    config: {}
  images:
    x86: hello-world
  env:
  - key: MY_ENV
    value: 42
  ports:
  - internal: 80
    external: 5000
  rootHostAccess: true
  volumes: []
  commands: []
  config:
    config-key: 'config-value'
  application: my-app
  routes:
  - my-dest-msvc
```

After:
```yaml
apiVersion: iofog.org/v2
kind: Microservice # Or application, as application uses the same spec for its microservices
metadata:
  name: my-msvc
spec:
  agent:
    name: agent-name
    config: {}
  images:
    x86: hello-world
  container:
    env:
    - key: MY_ENV
      value: 42
    ports:
    - internal: 80
      external: 5000
    rootHostAccess: true
    volumes: []
    commands: []
  config:
    config-key: 'config-value'
  application: my-app
  routes:
  - my-dest-msvc
```

This should make clearer what relates to the ioFog microservice, and what relates to the configuration of the actual container running on the Agent.

## Configure default namespace

You don't need to add `-n <namespace>` after each command if you want to use namespaces.
You can now configure which namespace is used as the default one by running:

```bash
$> iofogctl configure default-namespace NAMESPACE
```

## Prune Docker on an Agent

Your agent is running out of diskspace ? You can now manually run a pruning of the docker images on your Agent by using iofogctl:

```bash
$> iofogctl prune agent NAME
```

**Soon to come:**
You can also configure a automated pruning frequency using the `AgentConfig` kind

```yaml
apiVersion: iofog.org/v2
kind: AgentConfig
metadata:
  name: <agent_name>
spec:
  pruningFrequency: 300 # Prune every 300 seconds
```

## Move a microservice to another Agent

Up until now, if you needed to move a microservice to another agent, you had to update its deployment yaml file, and redeploy the microservice.

Now, you can simple use:
```bash
$> iofogctl move microservice NAME AGENT_NAME
```

## Detach / Attach an Agent

Ever wondered how to transfer an Agent from one ECN to another ? It's very simple:

```bash
$> iofogctl detach agent NAME
## ...
## Switch to another ECN / namespace
## ...
$> iofogctl attach agent NAME
```

Keep in mind that detaching an agent will delete its connection with the Controller, and all microservices will be shut down.

If you have an Agent ready and running on a remote host, you can also attach it directly using host and ssh credentials:
```bash
$> iofogctl attach agent NAME --host HOST --host AGENT_HOST --user SSH_USER --port SSH_PORT --key SSH_PRIVATE_KEY_PATH
```

## New Volume deployment kind

Does your microservice requires some secret files, or initialisation data ?

You have always been able to use volume mappings to mount agent folders into your microservice container. However, until now there was no way to send those files/folders to your Agent using iofgoctl.

We have now introduced a new `Volume` kind that, when deployed, will let iofogctl copy folders over to your Agents, using SSH connections.

```yaml
apiVersion: iofog.org/v2
kind: Volume
spec:
  source: /tmp/
  destination: /tmp/secrets/
  permissions: 666
  agents:
  - name: agent-1
  - name: agent-2
```

This will create a folder `/tmp/secrets/` on both agents `agent-1` and `agent-2`, and will copy the contents of `/tmp/` of the computer running iofogctl into it.

This is still very much a work in progress, a first naive implementation, and all feedback is appreciated.

## Microservice public ports

Your Agent is behind a firewall, in a private network, not accessible from another Agent, etc. but you need to be able to access a specific port exposed by a microservice ? Let us introduce "Public ports" !

When deploying applications and microservices, you can now specify extra fields (`public`, `host` and `protocol`) when configuring the port mappings of your container. 

If `public` is specified, this will open a tunnel that will forward all traffic incoming onto the port exposed by the container. 

`host` allows you to specify the Agent that will open the public port, the default value being that the public port is opened alongside your Controller (Same host for a Vanilla Controller, as a separate Load Balancer for a K8s deployment)

`protocol` let you decide between `http` and `tcp`. It tells the public port which type of traffic to forward. the default value is `http`.

```yaml
...
name: my-msvc
agent:
  name: agent-1
container:
  ...
  ports:
  - internal: 80
    external: 5000
    public: 5001
    protocol: tcp
...
```

Deploying such a configuration would result in port 5001 being opened on the Controller host, and all incoming tcp traffic would be tunneled to agent-1, port 5000.

The public address can be retrieved using:
```bash
$> iofogctl describe microservice NAME
```

The outputted yaml will contain a `publicLink` key, with the value set to the URL of the public port.

## Connector is dead, long live Skupper routers !

This would probably require an entire document to explain everything, but here is the gist of it !
We have removed Connector from ioFog, you can now remove all `Connector` kind schema from your deployments files.

The communication between Agents, the transmission of ioMessages and the public port tunneling is done using Skupper AMQP Dispatch routers.

By default, when deploying a Controller, an interior dispatch router gets deployed next to it. If not specified otherwise at deploy time, each Agent will run an edge dispatch router, connected to the main interior router.

Using the `AgentConfig` kind, it is possible to define your own network topology, and run an interior router on an Agent, or have an Agent that does not run any router but connects to the edge router of another accessible Agent on its network.

When the network topology is customised, it allows for direct communication between Agents on the same network, without going back to the cloud.

If you want to know more about this, please contact us on Slack and a member of our team will take the time of helping you through setting up your own network topology.